import { debounce } from "@yeger/debounce";

//#region src/index.ts
function useMasonryWall({ columns, columnWidth, emit, gap, items, maxColumns, minColumns, nextTick, onBeforeUnmount, onMounted, rtl, scrollContainer, ssrColumns, vue, wall, watch }) {
	function countIteratively(containerWidth, gap$1, count, consumed) {
		const nextWidth = getColumnWidthTarget(count);
		if (consumed + gap$1 + nextWidth <= containerWidth) return countIteratively(containerWidth, gap$1, count + 1, consumed + gap$1 + nextWidth);
		return count;
	}
	function getColumnWidthTarget(columnIndex) {
		const widths = Array.isArray(columnWidth.value) ? columnWidth.value : [columnWidth.value];
		return widths[columnIndex % widths.length];
	}
	function columnCount() {
		const boundedCount = aboveMin(belowMax(countIteratively(wall.value.getBoundingClientRect().width, gap.value, 0, -gap.value)));
		return boundedCount > 0 ? boundedCount : 1;
	}
	function belowMax(count) {
		const max = maxColumns?.value;
		if (!max) return count;
		return count > max ? max : count;
	}
	function aboveMin(count) {
		const min = minColumns?.value;
		if (!min) return count;
		return count < min ? min : count;
	}
	if (ssrColumns.value > 0) {
		const newColumns = createColumns(ssrColumns.value);
		items.value.forEach((_, i) => newColumns[i % ssrColumns.value].push(i));
		columns.value = newColumns;
	}
	let currentRedrawId = 0;
	async function fillColumns(itemIndex, assignedRedrawId) {
		if (itemIndex >= items.value.length) return;
		await nextTick();
		if (currentRedrawId !== assignedRedrawId) return;
		const columnDivs = [...wall.value.children];
		if (rtl.value) columnDivs.reverse();
		const target = columnDivs.reduce((prev, curr) => curr.getBoundingClientRect().height < prev.getBoundingClientRect().height ? curr : prev);
		columns.value[+target.dataset.index].push(itemIndex);
		await fillColumns(itemIndex + 1, assignedRedrawId);
	}
	async function redraw(force = false) {
		const newColumnCount = columnCount();
		if (columns.value.length === newColumnCount && !force) {
			if (vue === 2) emit("redraw-skip");
			else emit("redrawSkip");
			return;
		}
		columns.value = createColumns(newColumnCount);
		const scrollTarget = scrollContainer?.value;
		const scrollY = scrollTarget ? scrollTarget.scrollTop : window.scrollY;
		await fillColumns(0, ++currentRedrawId);
		if (scrollTarget) scrollTarget.scrollBy({ top: scrollY - scrollTarget.scrollTop });
		else window.scrollTo({ top: scrollY });
		emit("redraw");
	}
	const resizeObserver = typeof ResizeObserver === "undefined" ? void 0 : new ResizeObserver(debounce(() => redraw()));
	onMounted(() => {
		redraw();
		resizeObserver?.observe(wall.value);
	});
	onBeforeUnmount(() => resizeObserver?.unobserve(wall.value));
	watch([items, rtl], () => redraw(true));
	watch([
		columnWidth,
		gap,
		minColumns,
		maxColumns
	], () => redraw());
	return { getColumnWidthTarget };
}
function createColumns(count) {
	return Array.from({ length: count }).map(() => []);
}

//#endregion
export { useMasonryWall };
//# sourceMappingURL=index.mjs.map